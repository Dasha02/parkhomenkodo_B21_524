# -*- coding: utf-8 -*-
"""PAVI3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18to-uIzHsygxSuLaDvqLvzzRFe044VLy
"""

from PIL import Image, ImageDraw
import numpy as np
import random
import math


def monochrome(input_image):
    width, height = input_image.size
    output_image = Image.new('L', (width, height))
    pixels = output_image.load()

    for x in range(width):
        for y in range(height):
            r, g, b = input_image.getpixel((x, y))
            gray_value = int(0.299 * r + 0.587 * g + 0.114 * b)
            pixels[x, y] = gray_value

    return output_image


def salt_and_pepper_noise(input_image, noise_ratio):
    width, height = input_image.size
    output_image = input_image.copy()
    pixels = output_image.load()

    num_noise_pixels = int(noise_ratio * width * height)

    for i in range(num_noise_pixels):
        x = random.randint(0, width - 1)
        y = random.randint(0, height - 1)

        if random.random() < 0.5:
            pixels[x, y] = 0  # Соль
        else:
            pixels[x, y] = 255  # Перец

    return output_image


def closing(input_image, kernel_size):

    
    def dilation(image, kernel_size):
        width, height = image.size
        output_image = Image.new('L', (width, height))
        pixels_in = image.load()
        pixels_out = output_image.load()

        kernel_radius = kernel_size // 2

        for x in range(kernel_radius, width - kernel_radius):
            for y in range(kernel_radius, height - kernel_radius):
                max_value = 0
                for kx in range(-kernel_radius, kernel_radius + 1):
                    for ky in range(-kernel_radius, kernel_radius + 1):
                        max_value = max(max_value, pixels_in[x + kx, y + ky])
                pixels_out[x, y] = max_value

        return output_image


    def erosion(image, kernel_size):
        width, height = image.size
        output_image = Image.new('L', (width, height))
        pixels_in = image.load()
        pixels_out = output_image.load()

        kernel_radius = kernel_size // 2

        for x in range(kernel_radius, width - kernel_radius):
            for y in range(kernel_radius, height - kernel_radius):
                min_value = 255
                for kx in range(-kernel_radius, kernel_radius + 1):
                    for ky in range(-kernel_radius, kernel_radius + 1):
                        min_value = min(min_value, pixels_in[x + kx, y + ky])
                pixels_out[x, y] = min_value

        return output_image


    dilated_image = dilation(input_image, kernel_size)
    closed_image = erosion(dilated_image, kernel_size)

    return closed_image


def main(smth=None):

    filename = ["space1.png", "space2.png", "japan.png"]

    for i in range(len(filename)):

        input_image = Image.open(filename[i]).convert("RGB")

        monochrome_image = monochrome(input_image)

        noise_ratio = 0.05
        noisy_image = salt_and_pepper_noise(monochrome_image, noise_ratio)

        kernel_size = 3
        closed_image = closing(noisy_image, kernel_size)

        diff_image = Image.new('L', monochrome_image.size)
        pixels_diff = diff_image.load()
        pixels_mono = monochrome_image.load()
        pixels_closed = closed_image.load()

        for x in range(monochrome_image.size[0]):
            for y in range(monochrome_image.size[1]):
                diff_value = abs(pixels_mono[x, y] - pixels_closed[x, y])
                pixels_diff[x, y] = diff_value

        monochrome_image.save(f"{filename[i][:-4]}_monochrome_image.png")
        noisy_image.save(f"{filename[i][:-4]}_noisy_image.png")
        closed_image.save(f"{filename[i][:-4]}_closed_image.png")
        diff_image.save(f"{filename[i][:-4]}_diff_image.png")

if __name__ == "__main__":
    main()
